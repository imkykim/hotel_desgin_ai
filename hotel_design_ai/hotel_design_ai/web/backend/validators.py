"""
JSON schema validators for hotel design AI configuration files.
These validators ensure the JSON configurations generated by the LLM are valid.
"""

from pydantic import BaseModel, Field, validator, root_validator
from typing import Dict, List, Any, Optional, Union
import json


class BuildingEnvelopeSchema(BaseModel):
    """Schema for building envelope configuration"""

    width: float = Field(..., gt=0, description="Building width in meters")
    length: float = Field(..., gt=0, description="Building length in meters")
    height: float = Field(..., gt=0, description="Building height in meters")
    min_floor: int = Field(
        ..., description="Lowest floor number (negative for basement)"
    )
    max_floor: int = Field(..., ge=0, description="Highest floor number")
    floor_height: float = Field(..., gt=0, description="Height of each floor in meters")
    structural_grid_x: float = Field(
        ..., gt=0, description="Structural grid spacing in x-direction"
    )
    structural_grid_y: float = Field(
        ..., gt=0, description="Structural grid spacing in y-direction"
    )
    grid_size: float = Field(..., gt=0, description="Grid size for calculations")
    main_entry: str = Field(..., description="Main entry location")
    description: str = Field(..., description="Description of the building envelope")
    units: str = Field("meters", description="Units of measurement")

    @root_validator
    def check_floor_consistency(cls, values):
        """Validate that min_floor is less than max_floor and height is consistent with floors"""
        if not all(
            key in values
            for key in ["min_floor", "max_floor", "floor_height", "height"]
        ):
            return values

        min_floor = values["min_floor"]
        max_floor = values["max_floor"]
        floor_height = values["floor_height"]
        height = values["height"]

        if min_floor > max_floor:
            raise ValueError(
                f"min_floor ({min_floor}) must be less than or equal to max_floor ({max_floor})"
            )

        # Calculate expected height based on floors
        num_floors = max_floor - min_floor + 1
        expected_height = num_floors * floor_height

        # Allow some tolerance (10%) for height
        if not (0.9 * expected_height <= height <= 1.1 * expected_height):
            raise ValueError(
                f"Building height ({height}m) is inconsistent with floor count ({num_floors} floors) "
                f"and floor height ({floor_height}m). Expected around {expected_height}m."
            )

        return values


class RoomRequirementSchema(BaseModel):
    """Schema for an individual room requirement"""

    area: float = Field(..., gt=0, description="Room area in square meters")
    details: Optional[Dict[str, float]] = Field(
        None, description="Sub-spaces and their areas"
    )
    room_type: str = Field(..., description="Type of room")
    min_width: Optional[float] = Field(
        None, gt=0, description="Minimum width in meters"
    )
    min_height: Optional[float] = Field(
        None, gt=0, description="Minimum height in meters"
    )
    requires_natural_light: Optional[bool] = Field(
        None, description="Whether natural light is required"
    )
    requires_adjacency: Optional[List[str]] = Field(
        None, description="Required adjacent room types"
    )
    requires_separation: Optional[List[str]] = Field(
        None, description="Room types to avoid adjacency with"
    )
    floor: Optional[Union[int, List[int]]] = Field(
        None, description="Preferred floor(s)"
    )
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")

    @validator("details")
    def check_details_sum(cls, v, values):
        """Validate that the sum of details areas is roughly equal to the total area"""
        if v is None:
            return v

        area = values.get("area")
        if area is None:
            return v

        details_sum = sum(v.values())
        # Allow 10% tolerance
        if not (0.9 * area <= details_sum <= 1.1 * area):
            raise ValueError(
                f"Sum of details areas ({details_sum}) should approximately equal total area ({area})"
            )

        return v


class HotelRequirementsSchema(BaseModel):
    """Schema for the full hotel requirements"""

    public: Dict[str, RoomRequirementSchema]
    dining: Optional[Dict[str, RoomRequirementSchema]] = None
    meeting: Optional[Dict[str, RoomRequirementSchema]] = None
    recreational: Optional[Dict[str, RoomRequirementSchema]] = None
    administrative: Dict[str, RoomRequirementSchema]
    engineering: Dict[str, RoomRequirementSchema]
    circulation: Dict[str, RoomRequirementSchema]
    parking: Optional[Dict[str, RoomRequirementSchema]] = None


def validate_building_envelope(json_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validate building envelope data against schema

    Args:
        json_data: Building envelope data

    Returns:
        Validated data (may contain default values for optional fields)

    Raises:
        ValueError: If validation fails
    """
    try:
        validated = BuildingEnvelopeSchema(**json_data)
        return validated.dict()
    except Exception as e:
        raise ValueError(f"Building envelope validation failed: {str(e)}")


def validate_hotel_requirements(json_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validate hotel requirements data against schema

    Args:
        json_data: Hotel requirements data

    Returns:
        Validated data (may contain default values for optional fields)

    Raises:
        ValueError: If validation fails
    """
    try:
        # First validate each department and its rooms
        for dept, rooms in json_data.items():
            for room_name, room_data in rooms.items():
                RoomRequirementSchema(**room_data)

        # Then validate the entire structure
        validated = HotelRequirementsSchema(**json_data)
        return validated.dict()
    except Exception as e:
        raise ValueError(f"Hotel requirements validation failed: {str(e)}")


# Usage example
if __name__ == "__main__":
    # Example usage to test validators
    with open("example_building.json", "r") as f:
        building_data = json.load(f)
        validated_building = validate_building_envelope(building_data)
        print("Building envelope validation successful!")

    with open("example_requirements.json", "r") as f:
        requirements_data = json.load(f)
        validated_requirements = validate_hotel_requirements(requirements_data)
        print("Hotel requirements validation successful!")
